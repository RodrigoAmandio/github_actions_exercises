name: Pull Request Checking

on: 
  pull_request:
    types:
      - opened # Activity Type poderia ser assigned, unassigned, labeled, unlabeled, edited, closed, reopened, etc
      - synchronize # Novos commits adicionados ao mesmo PR
    
    branches:
      - develop # Apenas quando o PR tiver a main como destino
      - main
      # feature/** Branches que se iniciam com feature/...

# Environment Variables
# Quando declaradas no início, ficam disponíveis para todas as etapas do workflow
# Podem também ser declaradas dentro de cada respectivo job
# Environment Variables podem ser usadas dentro dos arquivos de workflow como também arquivos como .py para lógica de código, ex: os.environ['DB_HOST']
env:
  AWS_REGION: us-east-1
  ENVIRONMENT: production

jobs: 
  check-formatting: # Este espaço pode receber qualquer nome. Será o nome que aparecerá na esteira
    runs-on: ubuntu-latest # Cada job roda em uma máquina a parte. Este passo precisa ser repetido em cada um
    steps:
      - name: Checkout code # Este passo também necessita ser repetido a cada job
        uses: actions/checkout@v3 # GitHub Action used in workflows to check out your repository's code so subsequent steps in the workflow can access the files in it. It is like a download of the files.

      # Este step de cache precisa ser repetido em todos os steps que necessitam reaproveitar as dependências para que seja funcional
      # O cache é usado inclusive entre diferentes execuções de workflows, agilizando o trabalho
      # As dependências somente serão instaladas novamente caso o conteúdo de requirements.txt seja alterado
      # Não use cache para artifacts
      - name: Caching Dependencies # This caches the downloaded packages in ~/.cache/pip. If requirements.txt hasn’t changed, it reuses the cache.
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip # What to cache (file or folder path)
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }} # A unique identifier for the cache (e.g., based on OS and hash of requirements.txt)

      - name: Begin
        run: echo "Beginning to check code formatting"

      - name: Set up Python
        uses: actions/setup-python@v4 # Instalar a linguagem que se deseja usar. Neste caso, python
        with:
          python-version: '3.10'  # or any version you need

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run Black (check only)
        run: |
          echo "Checando a formatação do código com black"
          black --check .
      
      - name: Run Isort (check only)
        run: |
          echo "Checando a ordenação de imports com isort"
          isort --check .

      - name: Run Mypy (check only)
        run: |
          echo "Checando a estrutura do código com mypy"
          mypy --check python/main.py
  

  unit-test:
    needs: check-formatting # Com esse comando, será possível uma execução em sequência. Sem ele, ambos ops steps seriam executados em paralelo
    runs-on: ubuntu-latest
    outputs:
      script-file: ${{ steps.publish.outputs.file_name }} # Estrutura: steps.id.outputs.output_name
      # script-file é um nome que pode ser definido a critério do usuário
      user-name: ${{ steps.publish.outputs.user_name }}
      
    steps: 
      - name: Caching Dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Begin
        run: echo "Beginning unit tests on main.py"

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'  # or any version you need

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests with coverage
        run: | # O resultado do teste unitário será salvo em um arquivo coverage_report.txt na raiz do repo e disponibilizado com artefato para download, posteriormente
          coverage run -m unittest discover python/tests/
          coverage report > coverage_report.txt

      - name: Upload coverage report # Esta operaçao é chamada de Upload, pois envia o arquivo para o fluxo para uso em outras etapas
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage_report.txt # Será liberado este arquivo para download ao final do workflow
      
      - name: Publish Execution Variables # Simula uma situação em que é possível disponibilizar a variável do nome do arquivo para uma etapa posterior, por exemplo, CD
        id: publish
        run: |
          result=$(find python -maxdepth 1 -type f -name '*.py' -exec basename {} \;) 
          echo "file_name=$result" >> $GITHUB_OUTPUT
          echo "user_name=Rodrigo Amandio" >> $GITHUB_OUTPUT


  deploy: # Essa etapa irá simular a obtençao de um artefato de uma etapa para a outra, para uso em um possível CD após fechamento de Pull Request
    needs: unit-test
    runs-on: ubuntu-latest
    steps:
      - name: Get Github Artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: . # Irá fazer o download do artefato para a raiz
        
      - name: Output Coverage Content
        run: cat coverage_report.txt
      
      - name: Deploy
        run: echo "Fazendo deploy do recurso, simulando uma etapa de CD após fechamento com sucesso de Pull Request"
      
      - name: Output Varibles From Previous unit-test # needs.nome-step.output.nome-output
        run: |
          echo "File Name=${{ needs.unit-test.outputs.script-file }}"
          echo "User Name=${{ needs.unit-test.outputs.user-name }}"
      
      - name: Output Environment Variables
        run: |
          echo "Primeira forma de usar uma variável de ambiente: ${{env.AWS_REGION}}"
          echo "Segunda forma de usar uma variável de ambiente: $ENVIRONMENT"




        
          